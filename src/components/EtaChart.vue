<template>
  <v-chart class="chart" :option="option" autoresize />
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue'

import type { UnitType, DataRowType } from '../types'

const props = defineProps({
  data: { type: Array<DataRowType>, required: true },
  settings: {
    type: Object as () => { showDays: boolean; unitSpeed: UnitType },
    default: () => ({ showDays: false, unitSpeed: 'sec' as UnitType })
  },
  ips: { type: Number, required: false, default: 0 },
  target: { type: Number, default: 0 }
})

import VChart from 'vue-echarts'

// Start code generated by https://vue-echarts.dev/#codegen
import { use } from 'echarts/core'
import { LineChart } from 'echarts/charts'
import {
  TitleComponent,
  TooltipComponent,
  LegendComponent,
  GridComponent,
  MarkLineComponent
} from 'echarts/components'
import { CanvasRenderer } from 'echarts/renderers'
import type { ComposeOption } from 'echarts/core'
import type { LineSeriesOption } from 'echarts/charts'
import type {
  TitleComponentOption,
  TooltipComponentOption,
  LegendComponentOption,
  GridComponentOption,
  MarkLineComponentOption
} from 'echarts/components'

use([
  TitleComponent,
  TooltipComponent,
  LegendComponent,
  GridComponent,
  MarkLineComponent,
  LineChart,
  CanvasRenderer
])

type EChartsOption = ComposeOption<
  | TitleComponentOption
  | TooltipComponentOption
  | LegendComponentOption
  | GridComponentOption
  | MarkLineComponentOption
  | LineSeriesOption
>
// End generated code

const chartColors = ['#3ba272', '#5470c6', '#91cc75']

const unitFactor = computed(() => {
  return {
    sec: 1,
    min: 60,
    hour: 3600,
    day: 86400
  }[props.settings.unitSpeed]
})

const option = ref<EChartsOption>({
  // title: {
  //   text: 'Items and speed over time',
  //   left: 'center'
  // },
  tooltip: {},
  legend: {},
  series: [
    {
      type: 'line',
      smooth: true,
      symbolSize: 10,
      silent: true,
      animation: false,
      yAxisIndex: 0,
      data: props.data.map(row => [row.date, row.items]),
      color: chartColors[0],
      areaStyle: { opacity: 0.5 }
    },
    {
      type: 'line',
      smooth: true,
      symbolSize: 10,
      silent: true,
      animation: false,
      yAxisIndex: 1,
      color: chartColors[1],
      data: props.data.slice(1).map(row => [row.date, row.speed]),
      // TODO: use lin reg value from stats
      markLine: {
        symbol: 'none',
        label: { show: false },
        silent: true,
        animation: true,
        data: [{ yAxis: props.ips * unitFactor.value }]
      }
    }
  ],
  xAxis: { type: 'time' },
  yAxis: [
    {
      name: 'Value',
      position: 'left',
      type: 'value',
      nameTextStyle: { color: chartColors[0] },
      axisLabel: { color: chartColors[0] }
    },
    {
      name: 'Speed',
      type: 'value',
      position: 'right',
      nameTextStyle: { color: chartColors[1] },
      axisLabel: { color: chartColors[1] },
      splitLine: { show: false }, // no grid line,
      // set initial value based on target
      inverse: props.target == 0
    }
  ]
})

watch(
  [props.data, props.settings],
  () => {
    updateChart()
  },
  { deep: true }
)

function updateChart() {
  option.value.series = option.value.series as LineSeriesOption[]
  option.value.series[0].data = props.data.map(row => [row.date, row.items])
  option.value.series[1].data = props.data
    .slice(1)
    .map(row => [row.date, row.speed * unitFactor.value])
  if (option.value.series[1]?.markLine) {
    option.value.series[1].markLine.data = [{ yAxis: props.ips * unitFactor.value }]
  }
  // if speed is neg: invert axis
  if (props.data.length > 0) {
    // eslint-disable-next-line
    option.value.yAxis = (option.value.yAxis || []) as [{}, {}]
    option.value.yAxis[1].inverse = props.target == 0
  }
}
</script>

<style scoped>
.chart {
  height: 400px;
}
</style>
